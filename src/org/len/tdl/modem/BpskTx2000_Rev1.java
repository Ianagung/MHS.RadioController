/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.len.tdl.modem;

/**
 *
 * @author APS
 */
public class BpskTx2000_Rev1 
{
    private final double twopi = 6.2831853071795862;     // 2 * pi
    private final int Ns_x6 = 256 * 6;  
   // N = 145
    private final double[] h_rrc = {0.00012744224,-2.0806330e-05,-0.00017237118,-0.00032136220,-0.00046164458,-0.00058705424,-0.00069162709,-0.00076983462,-0.00081681821,-0.00082861388,-0.00080235902,-0.00073647354,-0.00063080690,-0.00048674503,-0.00030727035,-9.6970856e-05,0.00013800563,0.00039005341,0.00065026712,0.00090865477,0.0011544011,0.0013761774,0.0015624886,0.0017020515,0.0017841915,0.0017992486,0.0017389815,0.0015969531,0.0013688917,0.0010530088,0.00065026712,0.00016458480,-0.00039703160,-0.0010244338,-0.0017043634,-0.0024205728,-0.0031540347,-0.0038832414,-0.0045845876,-0.0052328310,-0.0058016242,-0.0062641008,-0.0065935119,-0.0067638876,-0.0067507168,-0.0065316213,-0.0060870121,-0.0054007038,-0.0044604787,-0.0032585755,-0.0017920948,-6.3303094e-05,0.0019201718,0.0041452632,0.0065935119,0.0092412382,0.012059841,0.015016211,0.018073266,0.021190589,0.024325142,0.027432082,0.030465612,0.033379875,0.036129877,0.038672384,0.040966831,0.042976134,0.044667482,0.046013039,0.046990495,0.047583580,0.047782380,0.047583580,0.046990495,0.046013039,0.044667482,0.042976134,0.040966831,0.038672384,0.036129877,0.033379875,0.030465612,0.027432082,0.024325142,0.021190589,0.018073266,0.015016211,0.012059841,0.0092412382,0.0065935119,0.0041452632,0.0019201718,-6.3303094e-05,-0.0017920948,-0.0032585755,-0.0044604787,-0.0054007038,-0.0060870121,-0.0065316213,-0.0067507168,-0.0067638876,-0.0065935119,-0.0062641008,-0.0058016242,-0.0052328310,-0.0045845876,-0.0038832414,-0.0031540347,-0.0024205728,-0.0017043634,-0.0010244338,-0.00039703160,0.00016458480,0.00065026712,0.0010530088,0.0013688917,0.0015969531,0.0017389815,0.0017992486,0.0017841915,0.0017020515,0.0015624886,0.0013761774,0.0011544011,0.00090865477,0.00065026712,0.00039005341,0.00013800563,-9.6970856e-05,-0.00030727035,-0.00048674503,-0.00063080690,-0.00073647354,-0.00080235902,-0.00082861388,-0.00081681821,-0.00076983462,-0.00069162709,-0.00058705424,-0.00046164458,-0.00032136220,-0.00017237118,-2.0806330e-05,0.00012744224};
    private final double[] z_rrc = new double[6];
    private final double[] map = {-1.0,1.0};
    private double theta = 1;
    private double t = 0.0;
    private int counter = 0;
    
    // -------------------------------- up sampler ----------------------------
    // note : 
    //   length(z) = nh/nu -> integer
    private void upSample(double[] x, double[] y, double[] z, double[] h, int nh, int nu, int nx) {
        int i, j, k, m, n;
        double tmp;
        double gain;

        gain = (double) (nu);
        n = 0;
        for (i = 0; i < nx; i++) {

            m = (nh / nu) - 1;
            for (j = m; j > 0; j--) {
                z[j] = z[j - 1];
            }
            z[0] = x[i];

            for (j = 0; j < nu; j++) {
                m = 0;
                tmp = 0;
                for (k = 0; k < nh; k += nu) {
                    tmp += z[m] * h[k + j];
                    m++;
                }
                y[n] = tmp * gain;
                n++;
            }
        }

        //return n;
    }
    

    
 
    

    
    public void transmit(int[] x, double[] out, double[] out2)
    {

        int i;
        double[] enc = new double[64];
        
        
        /*  ------------------------- DBPSK Modulation ---------------------- */

        for (i = 0; i < 64; i++) {
            enc[i] = 0.6 * theta;
            theta *= map[x[i]];
        }     
                
        // upsample
        upSample(enc, out, z_rrc, h_rrc, 144, 24, 64);

    
        /* ---------------------------- Upconversion --------------------- */

        //for (i = 0; i < Ns; i++) {
        //    out[i] = 16.0 * enc2[i] * cosx[i&7];
        //}

        double wt = twopi * 2000.0 / 48000.0;
        for (i = 0; i < Ns_x6; i++) { 
            out[i] *= Math.cos(t);
            t += wt;
            if (t >= twopi) {
                t -= twopi;
            }
        }
        
        for (i = 0; i < Ns_x6; i++)
            out2[i] = out[i];
        
    }
    
    public void transmit_reset()
    {
        t = 0;
        theta = 1;
        for (int i = 0; i < 6; i++)
            z_rrc[i] = 0;
        
    }
       
    public void setFrequencyOfset(double fo)
    {
        //frequency_ofset = fo;
    }
    
    public void setCounter(int count)
    {
        counter = 0;
    }

    public int getCounter()
    {
        return counter;
    }
}
