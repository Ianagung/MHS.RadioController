/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package org.len.tdl.modem;

/**
 *
 * @author ASUS
 */
public class BpskTx125 {
    
    private final int Ns = 256;                          // Number of sample
    private final int Norde = 65;                        // RRC Orde
    private final int D = 16;                            // Decimation factor
    private final int Nsym = 4;                          // Number of symbol
    private final double Fs = 8000.0;                    // Sampling frequency
    private final double twopi = 6.2831853071795862;     // 2 * pi

    private final int Ns_x6 = 256*6;  
    private final int Norde_up = 96; 
    private final double[] h_up = {-0.000372741292935656,-0.000699300330538713,-0.00105502397534662,-0.00141075686095526,-0.00173096357895102,-0.00197616904045692,-0.00210618432488512,-0.00208391454226439,-0.00187946470159399,-0.00147419690631717,-0.000864354893969112,-6.38658063042128e-05,0.000894042433235467,0.00195670604354756,0.00305357408653523,0.00409951887526627,0.00499984379790009,0.00565677407043133,0.00597706995725404,0.00588027296450662,0.00530699559543648,0.00422660501807428,0.00264363837245136,0.000602326928710093,-0.00181130163531621,-0.00447013276243769,-0.00720969475071496,-0.00983490664354306,-0.0121296176250591,-0.0138684892247539,-0.0148305695012094,-0.0148137427951371,-0.0136491241728458,-0.0112144155425879,-0.00744525747580910,-0.00234369879213199,0.00401693863004133,0.0114913084648000,0.0198656518885638,0.0288657366968776,0.0381687940362950,0.0474188436885607,0.0562445538530304,0.0642785894420928,0.0711772790014080,0.0766393846813892,0.0804227967788220,0.0823580927474076,0.0823580927474076,0.0804227967788220,0.0766393846813892,0.0711772790014080,0.0642785894420928,0.0562445538530304,0.0474188436885607,0.0381687940362950,0.0288657366968776,0.0198656518885638,0.0114913084648000,0.00401693863004133,-0.00234369879213199,-0.00744525747580910,-0.0112144155425879,-0.0136491241728458,-0.0148137427951371,-0.0148305695012094,-0.0138684892247539,-0.0121296176250591,-0.00983490664354306,-0.00720969475071496,-0.00447013276243769,-0.00181130163531621,0.000602326928710093,0.00264363837245136,0.00422660501807428,0.00530699559543648,0.00588027296450662,0.00597706995725404,0.00565677407043133,0.00499984379790009,0.00409951887526627,0.00305357408653523,0.00195670604354756,0.000894042433235467,-6.38658063042128e-05,-0.000864354893969112,-0.00147419690631717,-0.00187946470159399,-0.00208391454226439,-0.00210618432488512,-0.00197616904045692,-0.00173096357895102,-0.00141075686095526,-0.00105502397534662,-0.000699300330538713,-0.000372741292935656};
    private final double[] z_up_re = new double[Norde_up];
    private final double[] z_up_im = new double[Norde_up];
    
    private final double[] map = {-1.0,1.0};
    //private final double[] cosx = {1.0,0.7071,0.0,-0.7071,-1.0,-0.7071,0.0,0.7071};
    private final double[] coef1 =  
    { 0.0026525823848649226,  0.0026448339056038047,  0.00237421260100383,
      0.0018166678587446703,  0.000966761268258366,  -0.00015951285504790959,
     -0.0015230400272629022, -0.0030612336677564196, -0.0046891474799849288,
     -0.0063020947155263945, -0.0077797232058251092, -0.00899139970885807,
     -0.0098026662947067154, -0.010082451283302461,  -0.0097106532740502648,
     -0.0085856738310128456, -0.0066314559621623026, -0.0038035937323875621,
     -9.4113596766722977E-5,  0.0044654109758902267,  0.0098026662947067154,
      0.015805479421311584,   0.022324811744454776,   0.029179783533067757,
      0.036164529352034396,   0.043056574559822758,   0.04962632913988077,
      0.055647222854718535,   0.060905959900277043,   0.065212355047554141,
      0.068408228059114021,   0.070374878426730458,   0.071038735772973843,
      0.070374878426730458,   0.068408228059114021,   0.065212355047554141,
      0.060905959900277043,   0.055647222854718535,   0.04962632913988077,
      0.043056574559822758,   0.036164529352034396,   0.029179783533067757,
      0.022324811744454776,   0.015805479421311584,   0.0098026662947067154,
      0.0044654109758902267, -9.4113596766722977E-5, -0.0038035937323875621,
     -0.0066314559621623026, -0.0085856738310128456, -0.0097106532740502648,
     -0.010082451283302461,  -0.0098026662947067154, -0.00899139970885807,
     -0.0077797232058251092, -0.0063020947155263945, -0.0046891474799849288,
     -0.0030612336677564196, -0.0015230400272629022, -0.00015951285504790959,
      0.000966761268258366,   0.0018166678587446703,  0.00237421260100383,
      0.0026448339056038047,  0.0026525823848649226 };

    private final double[] coef2 = 
      { 2.52679360639577E-5, 0.000133238259293725, 0.000331317357469105,
        0.00065536837935632, 0.00105578385830679, 0.00142374493781925,
        0.00157504657658547, 0.00130217538354493, 0.000452939912478612,
        -0.000967172589324984, -0.00271434516098723, -0.00429115748864553,
        -0.00503418938432388, -0.00430967864717408, -0.00177818997488116,
        0.00235438305386327, 0.00720562653224398, 0.0112985326794499,
        0.012895946714762, 0.0105422549009661, 0.00367743136733803,
        -0.00687293802852344, -0.0187318644044955, -0.0282623609869945,
        -0.0313221050717744, -0.0243350794617172, -0.00540645440791185,
        0.0248489163677652, 0.0630495303573265, 0.103505665259653, 0.139336717014583,
        0.163990859629882, 0.172776350989196, 0.163990859629882, 0.139336717014583,
        0.103505665259653, 0.0630495303573265, 0.0248489163677652,
        -0.00540645440791185, -0.0243350794617172, -0.0313221050717744,
        -0.0282623609869945, -0.0187318644044955, -0.00687293802852344,
        0.00367743136733803, 0.0105422549009661, 0.012895946714762,
        0.0112985326794499, 0.00720562653224398, 0.00235438305386327,
        -0.00177818997488116, -0.00430967864717408, -0.00503418938432388,
        -0.00429115748864553, -0.00271434516098723, -0.000967172589324984,
        0.000452939912478612, 0.00130217538354493, 0.00157504657658547,
        0.00142374493781925, 0.00105578385830679, 0.00065536837935632,
        0.000331317357469105, 0.000133238259293725, 2.52679360639577E-5 };
    
    
    // Transmiter global variable :
    private double theta = 1;
    private final double[] state1 = new double[Norde];
    private final double[] state2 = new double[Norde];
    private final double[] out_bb = new double[Ns];
    private final double[] out_re = new double[Ns];
    private final double[] out_im = new double[Ns];
    private double frequency_ofset = 1000.0;
    private double t = 0.0;
    private int counter = 0;
    
    // -------------------------------- up sampler ----------------------------
    // note : 
    //   length(z) = nh/nu -> integer
    private void upSample(double[] x, double[] y, double[] z, double[] h, int nh, int nu, int nx) {
        int i, j, k, m, n;
        double tmp;
        double gain;

        gain = (double) (nu);
        n = 0;
        for (i = 0; i < nx; i++) {

            m = (nh / nu) - 1;
            for (j = m; j > 0; j--) {
                z[j] = z[j - 1];
            }
            z[0] = x[i];

            for (j = 0; j < nu; j++) {
                m = 0;
                tmp = 0;
                for (k = 0; k < nh; k += nu) {
                    tmp += z[m] * h[k + j];
                    m++;
                }
                y[n] = tmp * gain;
                n++;
            }
        }

        //return n;
    }
    
    // -------------------------------- down sample ---------------------------
    // note :
    //   length(z) = nh
    //   nh/nd -> integer
    private void downSample(double[] x, double[] y, double[] z, double[] h, int nh, int nd, int nx) {
        int i, j, k;
        double tmp;

        k = 0;
        for (i = (nd - 1); i < nx; i += nd) {

            for (j = (nh - 1); j > (nd - 1); j--) {
                z[j] = z[j - nd];
            }

            for (j = 0; j < nd; j++) {
                z[j] = x[i - j];
            }

            tmp = 0;
            for (j = 0; j <= (nh - nd); j++) {
                tmp += z[j + (nd - 1)] * h[j];
            }
            y[k] = tmp;
            k++;
        }
    }
    
    private void fir(double[] x, double[] y, double[] z, double[] h, int nh, int ny) {
        int i, j;
        double tmp;

        for (i = 0; i < ny; i++) {
            for (j = (nh - 1); j > 0; j--) {
                z[j] = z[j - 1];
            }
            z[0] = x[i];

            tmp = 0;
            for (j = 0; j < nh; j++) {
                tmp += z[j] * h[j];
            }
            y[i] = tmp;
        }
    }
    
    

    
    public void transmit(int[] x, double[] out, double[] out2)
    {

        int i,j;
        double tmp;
        double[] enc = new double[64];
        double[] enc2 = new double[256];
        
        
        /*  ------------------------- DBPSK Modulation ---------------------- */

        for (i = 0; i < 64; i++)
            enc[i] = 0.0;

        for (i = 0; i < Nsym; i++) {
            enc[i * 16] = theta;
            theta *= map[x[i]];
        }

        /*  ---------------------------- RRC Filter 1 --------------------- */

        for (i = 0; i < 64; i++) {
            for (j = 0; j < (Norde-1); j++)
                state1[j] = state1[j+1];
            state1[Norde-1] = enc[i];
            tmp = 0.0;
            for (j = 0; j < Norde; j++)
                tmp += coef1[j] * state1[j];
            enc[i] = tmp;
        }

        /*  ---------------------------- RRC Filter 2 --------------------- */

        for (i = 0; i < Ns; i++)
            enc2[i] = 0.0;

        for (i = 0; i < 64; i++)
            enc2[i << 2] = enc[i];

        for (i = 0; i < Ns; i++) {
            for (j = 0; j < (Norde-1); j++)
                state2[j] = state2[j+1];
            state2[Norde-1] = enc2[i];
            tmp = 0.0;
            for (j = 0; j < Norde; j++)
                tmp += coef2[j] * state2[j];
            enc2[i] = tmp;
        }

        /* ---------------------------- Upconversion --------------------- */

        //for (i = 0; i < Ns; i++) {
        //    out[i] = 16.0 * enc2[i] * cosx[i&7];
        //}

        double wt = twopi * frequency_ofset / Fs;
        for (i = 0; i < Ns; i++) { 
            out_bb[i] = 16.0 * enc2[i] * Math.cos(t);
            t += wt;
            if (t >= twopi) {
                t -= twopi;
            }
        }
          
        // upsample
        upSample(out_bb, out, z_up_re, h_up, Norde_up, 6, Ns);
        for (i = 0; i < Ns_x6; i++)
            out2[i] = out[i];
        
    }
    
    public void transmit_reset()
    {
        t = 0;
        theta = 1;
        
        for (int i = 0; i < Norde; i++) {
            state1[i] = 0;
            state2[i] = 0;
        }
        
        for (int i = 0; i < Norde_up; i++)
            z_up_re[i] = 0;
        
    }
       
    public void setFrequencyOfset(double fo)
    {
        frequency_ofset = fo;
    }
    
    public void setCounter(int count)
    {
        counter = 0;
    }

    public int getCounter()
    {
        return counter;
    }
    
    

        
        
        
    
    
    
    
}
